% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/polyhedra-lib.R
\docType{class}
\name{PolyhedronStateDefined.class}
\alias{PolyhedronStateDefined.class}
\title{Polyhedron State Defined}
\format{\code{\link{R6Class}} object.}
\description{
Polyhedron State Defined

Polyhedron State Defined
}
\details{
Polyhedron state inside database.
}
\section{Methods}{

\describe{
  \item{\code{initialize(source, file.id, name, symbol, dual,
              sfaces, svertices, net, solid, hinges, dih, vertices)}}{
              Initializes the object, taking defaults.}
  \item{\code{scrape()}}{Do nothing as the object is defined}
  \item{\code{getName()}}{returns polyhedron name}
  \item{\code{getNet()}}{Gets the 2d net model}
  \item{\code{getSolid()}}{Gets the solid representation}
  \item{\code{triangulate(force = FALSE, vertices)}}{Generates
   the triangular faces model for generating tmesh }
  \item{\code{getConvHull(self$transformation.matrix, vertices.id.3d)}}{Gets the Convex Hull of
  the object vertices}
  \item{\code{calculateMassCenter(size = 1, vertices.3d)}}{Calculates
  the object's Mass Center for parameter
        vertices}
  \item{\code{getNormalizedSize(size, vertices.id.3d =
  private$vertices.id.3d)}}{Normalizes the convex hull volume of the object to a
  tetrahedron Convex Hull volume}
  \item{\code{applyTransformationMatrix(transformation.matrix)}}{Apply
  transformation matrix to internal transformation matrix}
  \item{\code{resetTransformationMatrix()}}{Reset internal transformation matrix}
  \item{\code{getTransformedVertices(vertices,
  transformation.matrix)}}{Returns the vertices
  adjusted with transformation matrix}
  \item{\code{buildRGL(transformation.matrix)}}{Builds the \code{RGL} model}
  \item{\code{exportToXML()}}{Gets an XML representation out of
  the polyhedron object}
  \item{\code{serialize()}}{Gets a list representation out
  of the polyhedron object}
  \item{\code{expectEqual()}}{Function which test equal values
  for all fields using serialize function}

}
for RGL visualization
}

\section{Super class}{
\code{\link[Rpolyhedra:PolyhedronState]{Rpolyhedra::PolyhedronState}} -> \code{PolyhedronStateDefined}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{mass.center}}{polyhedron mass center}

\item{\code{edges.cont}}{Edges count}

\item{\code{edges.check}}{Edges check degree property}

\item{\code{vertices.id.3d}}{vertices definition for solid 3d object}

\item{\code{vertices.rgl}}{Polyhedron triangulated vertices list for RGL}

\item{\code{solid.triangulated}}{Polyhedron solid (triangulated)}

\item{\code{file.id}}{polyhedron filename in original}

\item{\code{source}}{polyhedron definition source (netlib|dmccooey)}

\item{\code{name}}{polyhedron name (netlib|dmccooey)}

\item{\code{symbol}}{the eqn(1) input for two symbols separated by a tab;
the Johnson symbol, and the Schlafli symbol (netlib)}

\item{\code{dual}}{the name of the dual polyhedron optionally followed
by a horizontal tab and the number of the dual (netlib)}

\item{\code{sfaces}}{polyhedron solid face list (netlib)}

\item{\code{svertices}}{polyhedron solid vertices list (netlib)}

\item{\code{vertices}}{Polyhedron vertices list (netlib|dmccooey)}

\item{\code{vertices.centered}}{centered vertices for applying
transformation matrices}

\item{\code{net}}{polyhedron 2D net model with vertices defined for
a planar representation (netlib)}

\item{\code{solid}}{polyhedron list of edges which generate a
solid (netlib|dmccooey)}

\item{\code{hinges}}{Polyhedron hinge list (netlib)}

\item{\code{dih}}{Dih attribute (netlib)}

\item{\code{polyhedron}}{edges (netlib|dmccooey)}

\item{\code{transformation.matrix}}{transformation matrix for
calculations and visualizing polyhedron}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{mass.center}}{polyhedron mass center}

\item{\code{edges.cont}}{Edges count}

\item{\code{edges.check}}{Edges check degree property}

\item{\code{vertices.id.3d}}{vertices definition for solid 3d object}

\item{\code{vertices.rgl}}{Polyhedron triangulated vertices list for RGL}

\item{\code{solid.triangulated}}{Polyhedron solid (triangulated)}

\item{\code{polyhedron}}{edges (netlib|dmccooey)}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{PolyhedronStateDefined.class$new()}}
\item \href{#method-scrape}{\code{PolyhedronStateDefined.class$scrape()}}
\item \href{#method-getName}{\code{PolyhedronStateDefined.class$getName()}}
\item \href{#method-getSymbol}{\code{PolyhedronStateDefined.class$getSymbol()}}
\item \href{#method-adjustVertices}{\code{PolyhedronStateDefined.class$adjustVertices()}}
\item \href{#method-getVertices}{\code{PolyhedronStateDefined.class$getVertices()}}
\item \href{#method-getNet}{\code{PolyhedronStateDefined.class$getNet()}}
\item \href{#method-getSolid}{\code{PolyhedronStateDefined.class$getSolid()}}
\item \href{#method-inferEdges}{\code{PolyhedronStateDefined.class$inferEdges()}}
\item \href{#method-checkEdgesConsistency}{\code{PolyhedronStateDefined.class$checkEdgesConsistency()}}
\item \href{#method-triangulate}{\code{PolyhedronStateDefined.class$triangulate()}}
\item \href{#method-getConvHull}{\code{PolyhedronStateDefined.class$getConvHull()}}
\item \href{#method-calculateMassCenter}{\code{PolyhedronStateDefined.class$calculateMassCenter()}}
\item \href{#method-getNormalizedSize}{\code{PolyhedronStateDefined.class$getNormalizedSize()}}
\item \href{#method-getTransformedVertices}{\code{PolyhedronStateDefined.class$getTransformedVertices()}}
\item \href{#method-resetTransformationMatrix}{\code{PolyhedronStateDefined.class$resetTransformationMatrix()}}
\item \href{#method-applyTransformationMatrix}{\code{PolyhedronStateDefined.class$applyTransformationMatrix()}}
\item \href{#method-buildRGL}{\code{PolyhedronStateDefined.class$buildRGL()}}
\item \href{#method-exportToXML}{\code{PolyhedronStateDefined.class$exportToXML()}}
\item \href{#method-expectEqual}{\code{PolyhedronStateDefined.class$expectEqual()}}
\item \href{#method-serialize}{\code{PolyhedronStateDefined.class$serialize()}}
\item \href{#method-clone}{\code{PolyhedronStateDefined.class$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="Rpolyhedra" data-topic="PolyhedronState" data-id="addError">}\href{../../Rpolyhedra/html/PolyhedronState.html#method-addError}{\code{Rpolyhedra::PolyhedronState$addError()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$new(
  source,
  file.id,
  name,
  vertices,
  solid,
  net = NULL,
  symbol = "",
  dual = NULL,
  sfaces = NULL,
  svertices = NULL,
  hinges = NULL,
  dih = NULL,
  normalize.size = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file.id}}{identifier of the definition file.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new  `PolyhedronStateDefined` object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-scrape"></a>}}
\subsection{Method \code{scrape()}}{
scrape polyhedron.
As the state is defined this functions do nothing
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$scrape()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
current object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getName"></a>}}
\subsection{Method \code{getName()}}{
get Polyhedron name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getName()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
string with polyhedron name
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getSymbol"></a>}}
\subsection{Method \code{getSymbol()}}{
get Polyhedron symbol
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getSymbol()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
string with polyhedron symbol
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-adjustVertices"></a>}}
\subsection{Method \code{adjustVertices()}}{
adjust polyhedron Vertices
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$adjustVertices(normalize.size = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Returns}{
modified  `PolyhedronStateDefined` object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getVertices"></a>}}
\subsection{Method \code{getVertices()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getVertices(solid = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getNet"></a>}}
\subsection{Method \code{getNet()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getNet()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getSolid"></a>}}
\subsection{Method \code{getSolid()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getSolid()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-inferEdges"></a>}}
\subsection{Method \code{inferEdges()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$inferEdges(force.recalculation = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-checkEdgesConsistency"></a>}}
\subsection{Method \code{checkEdgesConsistency()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$checkEdgesConsistency()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-triangulate"></a>}}
\subsection{Method \code{triangulate()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$triangulate(force = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getConvHull"></a>}}
\subsection{Method \code{getConvHull()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getConvHull(
  transformation.matrix = self$transformation.matrix,
  vertices.id.3d = private$vertices.id.3d
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-calculateMassCenter"></a>}}
\subsection{Method \code{calculateMassCenter()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$calculateMassCenter(
  vertices.id.3d = private$vertices.id.3d,
  applyTransformation = TRUE
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getNormalizedSize"></a>}}
\subsection{Method \code{getNormalizedSize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getNormalizedSize(size)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getTransformedVertices"></a>}}
\subsection{Method \code{getTransformedVertices()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$getTransformedVertices(
  vertices = self$vertices.centered,
  transformation.matrix = self$transformation.matrix
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-resetTransformationMatrix"></a>}}
\subsection{Method \code{resetTransformationMatrix()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$resetTransformationMatrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-applyTransformationMatrix"></a>}}
\subsection{Method \code{applyTransformationMatrix()}}{
Apply transformation matrix to polyhedron
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$applyTransformationMatrix(transformation.matrix)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{transformation.matrix}}{the transformation matrix to apply to the polyhedron}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
an applied transformation.matrix
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-buildRGL"></a>}}
\subsection{Method \code{buildRGL()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$buildRGL(transformation.matrix = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-exportToXML"></a>}}
\subsection{Method \code{exportToXML()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$exportToXML()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-expectEqual"></a>}}
\subsection{Method \code{expectEqual()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$expectEqual(polyhedron)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-serialize"></a>}}
\subsection{Method \code{serialize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$serialize()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PolyhedronStateDefined.class$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
